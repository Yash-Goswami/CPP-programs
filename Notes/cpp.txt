by default members of structure are public and inside structures you can have only variables you can't have methods
that's why classes are invented
classes can have variables as well as methods and bydefault all members of class are private hence it's better with respect to security of the data

only static members of class get's initialized to default values in C++, all other non staic variables don't get initialized hence they will always have garbage value

class Employee{
  static int count;
};

int Employee::count=1111;

so static variable's you need to write at two places inside class also using static keyword you need to write
and outside class also after defining class , you need again declare to write with class name and now no need to write static keyword here
this is how compiler will under stand that this is static variable of class and it will by default ititialize it with 0, if you don't initialize it
static vars can't get initialized inside class you've to initialize it outside class only 

que: how to share data across the objects of single class?
ans: ofcourse by making static variables
because static variables can be accessed by all the objects of class, all object's can read same data using static variable

that's why non static methods can access static variables because It's a class variable hence without using object name directly that variable can be accessed
But
static method can't access non static variables 
it has 2 reasons
1) static members exist even before making object of class hence when you call static method using class name which is accessing non static vars ofcourse it will give error
bcoz no any object exist hence no any non static vars exist at this point of time
2) another reason is , suppose there are three objects of class x ,y,z and now using class name you are calling static method and try to access some variable i
static void fun(){
  i++;
}
now which i is this? is this i belogs to x or y or z? that compiler won't be able to understand that's why this will also give error 
because i exist 3 times bcoz it's not a static 
hence non static function can access static members
but 
static member's can't access non static members


class Complex(){
  int a,b;
  public:
    void setNumber(int x,int Y);
    friend Complex addNumber(Complex O1,Complex O2);
};
void Complex::setNumber(int x,int y){
   a=x,b=y;
}

Complex addNumber(Complex O1, Complex O2){
  Complex O3;
  O3.setNumber(O1.a+O2.a , O1.b+O2.b);
  return O3;
};

int main (){
  Complex O1,O2,O3;
  O1.setNumber(2,3);
  O2.setNumber(3,5);
  o3=addNumber(o1,o2);

}

friend function are used to access private members of any class 
when we want to perform operation using private members of more than one class then we can declare a function as friend to both those classes 
same function can be friend of many classes
friend function is separate entity it's not member of any class
classes are just making that function as their friend. by declaring any function as friend in any classes all the private member of that class can be access through that function

you can see the difference when you defining both function above
when you are defining class member function you have to use Class name and scope resolution operator 
but while defining friend function no need to use class name because friend function is not member of any class it's just friend of class 

you can declare friend function in public as well as private both the section, even if you declare any friend function as private , nothing will change in implementation still you can access it outside simply
nothng will change because friend function is not member of class hence declare in public or private doesn't makes any difference

another difference in friend function and in member function is in member function you can directly access a , b vars w/o using obj name
but in friend function you can't access vars w/o object name you have to use object and membership operator  like obj.a obj.b
because if you only write b then whose b is this? is this O1's b or O2's b , hence compiler will get confused

another difference b/w member function and friend function is member function can be called using obj.setNumber() only but friend function is not member of any class hence no need of obj.function_name

making other member's function as friend to other class , Member class, Forward declaration etc, watch video 27 of code with harry c++ playlist
https://www.youtube.com/watch?v=Tk-4KUoatg8&list=PLu0W_9lII9agpFUAlPFe_VNSlXW5uE0YL&index=27&ab_channel=CodeWithHarry

Constructors
if you don't make any constructor then compiler will make 2 constructors by default in all the classes
one is default constructor which takes no any argument
another is copy constructor which only does shallow copy

now if you have only one variable inside class which you want to set while creating object
then 
Student s(9); is same as Student S=9;
s(9) is same as s=9 only during the declaration line 
if after declaration of s object you assing then assignment operator will get invoked which ofcourse you've not defined in your class so it will lead to error

member function of class can access any member of class whether it's public or private or protected 
hence if we've two object o1 and o2 then o1's method can also access all varibales of o2 also because they both belongs to same class only

Dynamic memory allocation
int *ptr = new int;       //for single variable
int *ptr1 = new int[n];    //for array of size n

for freeup the dynamically allocated memory
delete ptr; //for deleting memory pointed by ptr
delete[] ptr1;  //if ptr1 is pointing to an array then you've to tell compiler that you need to free up entire array hence here square brackets [] are required along with delete keyword 

when you don't create any constructor , compiler will create default constructor which will not take any parameter
but when you create even single constructor now compiler will not create default constructor
and if your constructor which you've created is parameterized constructor then while creating objects you've to 
pass those parameter , now simply you can't create object like
Student s; // this will lead to an error that no matching function 
because now there's no any default parameterless constructor exists , if you want to resolve this error and you still want to create normal parameter less objects then you have to create one more default constructor along with your parameterized constructor

class Student{
  string name;
  int id;
  public:
  Student(){}
  Student(int id){
    this->id=id;
  }
};
//deep copy constructor
class Employee{
    int size;
    int *Ptr;
    public:
      Employee(Employee &obj){   //think on this why here we have to use reference variable
         size=obj.size;
         ptr=new int[size];
         for(int i=0;i<size;i++){
            ptr[i]=obj.ptr[i];
         }
      }
};

Employee E1;
Employee E2(E1); => this is same as Employee E2=E1; // both syntax will call copy constructor only

but if you write in next line like this,
Employee E2;
E2=E1; then now = operaotr of class Employee will get called , and if you've not defined it then you have to overload = operaotr for your class

now, while making copy constructor why we used reference variable and why we did not used normal variable?
because when you write Employee E2(E1); then internally it will implement at copy constructor as obj=E2
this obj is object which we used while making copy constructor
so now obj=E2 is same as obj(E2) this means again copy construcotr will be called for obj 
and this way it will lead to call back hell hence to avoid it we have to use reference variable

Destructor:
class Number(){
  public :
    ~Number(){

    }
}

Destructor deoesn't takes any parameters, hence only one destructor is possible hence there's no overloading possible for destructor

constructor overloading is possible because parameterized constructor are possible
so, any class can have multiple constructors but only one destructor is possible
