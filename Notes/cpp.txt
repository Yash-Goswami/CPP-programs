by default members of structure are public and inside structures you can have only variables you can't have methods
that's why classes are invented
classes can have variables as well as methods and bydefault all members of class are private hence it's better with respect to security of the data

only static members of class get's initialized to default values in C++, all other non staic variables don't get initialized hence they will always have garbage value

class Employee{
  static int count;
};

int Employee::count=1111;

so static variable's you need to write at two places inside class also using static keyword you need to write
and outside class also after defining class , you need again declare to write with class name and now no need to write static keyword here
this is how compiler will under stand that this is static variable of class and it will by default ititialize it with 0, if you don't initialize it
static vars can't get initialized inside class you've to initialize it outside class only 

que: how to share data across the objects of single class?
ans: ofcourse by making static variables
because static variables can be accessed by all the objects of class, all object's can read same data using static variable

that's why non static methods can access static variables because It's a class variable hence without using object name directly that variable can be accessed
But
static method can't access non static variables 
it has 2 reasons
1) static members exist even before making object of class hence when you call static method using class name which is accessing non static vars ofcourse it will give error
bcoz no any object exist hence no any non static vars exist at this point of time
2) another reason is , suppose there are three objects of class x ,y,z and now using class name you are calling static method and try to access some variable i
static void fun(){
  i++;
}
now which i is this? is this i belogs to x or y or z? that compiler won't be able to understand that's why this will also give error 
because i exist 3 times bcoz it's not a static 
hence non static function can access static members
but 
static member's can't access non static members


class Complex(){
  int a,b;
  public:
    void setNumber(int x,int Y);
    friend Complex addNumber(Complex O1,Complex O2);
};
void Complex::setNumber(int x,int y){
   a=x,b=y;
}

Complex addNumber(Complex O1, Complex O2){
  Complex O3;
  O3.setNumber(O1.a+O2.a , O1.b+O2.b);
  return O3;
};

int main (){
  Complex O1,O2,O3;
  O1.setNumber(2,3);
  O2.setNumber(3,5);
  o3=addNumber(o1,o2);

}

friend function are used to access private members of any class 
when we want to perform operation using private members of more than one class then we can declare a function as friend to both those classes 
same function can be friend of many classes
friend function is separate entity it's not member of any class
classes are just making that function as their friend. by declaring any function as friend in any classes all the private member of that class can be access through that function

you can see the difference when you defining both function above
when you are defining class member function you have to use Class name and scope resolution operator 
but while defining friend function no need to use class name because friend function is not member of any class it's just friend of class 

you can declare friend function in public as well as private both the section, even if you declare any friend function as private , nothing will change in implementation still you can access it outside simply
nothng will change because friend function is not member of class hence declare in public or private doesn't makes any difference

another difference in friend function and in member function is in member function you can directly access a , b vars w/o using obj name
but in friend function you can't access vars w/o object name you have to use object and membership operator  like obj.a obj.b
because if you only write b then whose b is this? is this O1's b or O2's b , hence compiler will get confused

another difference b/w member function and friend function is member function can be called using obj.setNumber() only but friend function is not member of any class hence no need of obj.function_name

making other member's function as friend to other class , Member class, Forward declaration etc, watch video 27 of code with harry c++ playlist
https://www.youtube.com/watch?v=Tk-4KUoatg8&list=PLu0W_9lII9agpFUAlPFe_VNSlXW5uE0YL&index=27&ab_channel=CodeWithHarry

Constructors
if you don't make any constructor then compiler will make 2 constructors by default in all the classes
one is default constructor which takes no any argument
another is copy constructor which only does shallow copy

now if you have only one variable inside class which you want to set while creating object
then 
Student s(9); is same as Student S=9;
s(9) is same as s=9 only during the declaration line 
if after declaration of s object you assing then assignment operator will get invoked which ofcourse you've not defined in your class so it will lead to error

member function of class can access any member of class whether it's public or private or protected 
hence if we've two object o1 and o2 then o1's method can also access all varibales of o2 also because they both belongs to same class only

Dynamic memory allocation
int *ptr = new int;       //for single variable
int *ptr1 = new int[n];    //for array of size n

for freeup the dynamically allocated memory
delete ptr; //for deleting memory pointed by ptr
delete[] ptr1;  //if ptr1 is pointing to an array then you've to tell compiler that you need to free up entire array hence here square brackets [] are required along with delete keyword 

when you don't create any constructor , compiler will create default constructor which will not take any parameter
but when you create even single constructor now compiler will not create default constructor
and if your constructor which you've created is parameterized constructor then while creating objects you've to 
pass those parameter , now simply you can't create object like
Student s; // this will lead to an error that no matching function 
because now there's no any default parameterless constructor exists , if you want to resolve this error and you still want to create normal parameter less objects then you have to create one more default constructor along with your parameterized constructor

class Student{
  string name;
  int id;
  public:
  Student(){}
  Student(int id){
    this->id=id;
  }
};
//deep copy constructor
class Employee{
    int size;
    int *Ptr;
    public:
      Employee(Employee &obj){   //think on this why here we have to use reference variable
         size=obj.size;
         ptr=new int[size];
         for(int i=0;i<size;i++){
            ptr[i]=obj.ptr[i];
         }
      }
};

Employee E1;
Employee E2(E1); => this is same as Employee E2=E1; // both syntax will call copy constructor only

but if you write in next line like this,
Employee E2;
E2=E1; then now = operaotr of class Employee will get called , and if you've not defined it then you have to overload = operaotr for your class

now, while making copy constructor why we used reference variable and why we did not used normal variable?
because when you write Employee E2(E1); then internally it will implement at copy constructor as obj=E2
this obj is object which we used while making copy constructor
so now obj=E2 is same as obj(E2) this means again copy construcotr will be called for obj 
and this way it will lead to call back hell hence to avoid it we have to use reference variable

Destructor:
class Number(){
  public :
    ~Number(){

    }
}

Destructor deoesn't takes any parameters, hence only one destructor is possible hence there's no overloading possible for destructor

constructor overloading is possible because parameterized constructor are possible
so, any class can have multiple constructors but only one destructor is possible


inheritance
class child : visibility_mode parent1,parent2.......
{
};

by default visibility mode is private if you don't mention any visibility mode

class Base{
  public :
    int fun(){
      cout<<"Base";
    }
};

class Derieved : public Base{
    public:
};

int main(){
  Derived obj;
  obj.fun(); //here when you create object then at compile time everything is known to compiler that how many things does 
            //obj has. obj will have all the properties of itself + all the public and protected properties of parent
            //BUT
  Derived *ptr=new Base()://BUT when you create pointer
  ptr->fun();    //here it will give error because ptr is of base class and base class doesn't have fun() function
  // why does it gave error ? because pointer is not like object which has all the information , pointer is just a variable
 //just a simple variable which can hold address that's it , it doesn't have any other information that what that class has
//what parent of that class has , pointer only knows one thing that it can store address 
//now you are creating object of parent using new and then you are assigning it to ptr but that's dynamic object and it will get created at run time and not at compile time , at compile time compiler only knows that ptr is of type Derived class
and if it has fun() then it will bind it at compile time otherwise it will give error because at compile time compiler doesn't know what's inside ptr and what ptr will be pointing to at run time 

//hence when you create object then it will go to parent and try to find function if it's not present in base class
//but if you create ptr then it won't be able to go to parent to find if function present of not at compile time
}

Diamond problem and Virtual Base class
    A
B        C
    D
B and C both are inheriting A
D has two parent class B and C 
now if A has some property let's say A has variable x 
so it will be inherited in B and C both 
now when D tries to access x then which x to access ? B.x or C.x ? that's the ambiguity and that's called diamond problem
and it's solution is virtual base class 

when you inherit A in B and C then declare A as virtual base class so that whenever any class inherit's B and C both like D
then A's property will only be reflect once in D

syntax:
class B : virtual public A            //virtual public or public virtual both we can write 
{
};

class C : virtual public A
{
};

class D : public class B,class C
{
};

Initializer list
class Test{
  int a;
  int b;
  public:

  Test(int i,int j):a(i) , b(j){   //so, this is the initialization section , using this also you can initialize variables
    //constructor body
  }
}

at line no. 232 we can try below things
Test(int i,int j):a(i) , b(i+j)
Test(int i,int j):a(2*i) , b(i+j)
Test(int i,int j):a(i) , b(a+j) //since we've declared a first and then b inside class hence a will get initialized first with i and then when compiler will go to initialize b then a's value will be available
BUT
Test(int i,int j):a(b+i) , b(j) //here compiler will first go to initialize a and at this point of time b's value is not available hence b has garbage value at this point of time hence garbage+i = garbage => so, a will be initialized with garbage value 

Test(int i,int j): b(j),a(b+i) // even you write b , before the a still a will get initialized first and then only b will get initialized hence here also b will have j's value but a will have garbage value


//constructor's calling order /execution order 
class Derived : public Base1 , public Base2
{
  int x,y;
  public:
  Derived(int a, int b, int c , int d) : Base2(d),Base1(c)
  {x=a,y=b}

}

whatever order you call at 252 line but still Base1(c) constructor will be executed first and then only Base2(d) will be executed because that's the order in which you've inherited at 248 line
so, the order in which you inherit in that order only constructors will get executed

BUT there's one exception with virtual base class , if any of your parent is virtual then irrespective of wherever you've written , virtual base class's constructor will always execute first

class Derived : public Base1 , public virtual Base2
{
  int x,y;
  public:
  Derived(int a, int b, int c , int d) : Base1(d),Base2(c)
  {x=a,y=b}

}
//although you are calling Base2's constructor after Base1's constructor but still Base2() constructor will be executed first becasue virtual base class is given highest priority

this pointer and how to return object which is calling It's funtion using this pointer watch video below
https://www.youtube.com/watch?v=cEOfK_L4gGA&list=PLu0W_9lII9agpFUAlPFe_VNSlXW5uE0YL&index=53&ab_channel=CodeWithHarry

video 55 https://www.youtube.com/watch?v=0YQ_yhX46uk&list=PLu0W_9lII9agpFUAlPFe_VNSlXW5uE0YL&index=55&ab_channel=CodeWithHarry
