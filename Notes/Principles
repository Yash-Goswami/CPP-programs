DRY : Don't Repeat yourself (tamari jaat ne repeat no thava dyo means don't rewrite the same code which you've already written somewhere instead use that code only again and again)
  Ex: inheritance is example of DRY principle where we are re-using paren't code in child classes instead of entirely re-writting the entire code 

Software Design Principles
-----------------
Great software isn't just about making things work,
it's about creating systems that are maintainable, scalable, and resilient.
These fundamental design principles guide developers toward writing better code.

1. ğŠğˆğ’ğ’ (ğŠğğğ© ğˆğ­ ğ’ğ¢ğ¦ğ©ğ¥ğ, ğ’ğ­ğ®ğ©ğ¢ğ)
âŸ The most elegant solutions are often the simplest.
âŸ Avoid unnecessary complexity, keep code clear and concise, and focus on essential features.
Remember that code is read far more often than it's written.

2. ğƒğ‘ğ˜ (ğƒğ¨ğ§'ğ­ ğ‘ğğ©ğğšğ­ ğ˜ğ¨ğ®ğ«ğ¬ğğ¥ğŸ)
âŸ Every piece of knowledge in a system should have a single, unambiguous representation.

3. ğ˜ğ€ğ†ğğˆ (ğ˜ğ¨ğ® ğ€ğ¢ğ§'ğ­ ğ†ğ¨ğ§ğ§ğš ğğğğ ğˆğ­)
âŸ Resist implementing features "just in case."
âŸ Build what's needed today.

4. ğ’ğğ‹ğˆğƒ ğğ«ğ¢ğ§ğœğ¢ğ©ğ¥ğğ¬
the backbone of object-oriented design:
âŸ Single Responsibility - Classes should do one thing well
âŸ Open/Closed - Open for extension, closed for modification
âŸ Liskov Substitution - Subtypes must be substitutable for their base types
âŸ Interface Segregation - Many specific interfaces beat one general interface
âŸ Dependency Inversion - Depend on abstractions, not concrete implementations

5. ğğ«ğ¢ğ§ğœğ¢ğ©ğ¥ğ ğ¨ğŸ ğ‹ğğšğ¬ğ­ ğ€ğ¬ğ­ğ¨ğ§ğ¢ğ¬ğ¡ğ¦ğğ§ğ­
âŸ Software should behave as users expect.
âŸ Consistency in terminology, conventions, and error messages creates intuitive experiences.

6. ğğ«ğ¢ğ§ğœğ¢ğ©ğ¥ğ ğ¨ğŸ ğŒğ¨ğğ®ğ¥ğšğ«ğ¢ğ­ğ²
âŸ Well-defined, independent modules make systems easier to understand, maintain, and test.

7. ğğ«ğ¢ğ§ğœğ¢ğ©ğ¥ğ ğ¨ğŸ ğ€ğ›ğ¬ğ­ğ«ğšğœğ­ğ¢ğ¨ğ§
âŸ Hide implementation details to reduce cognitive load.
âŸ Users of your code shouldn't need to know how it works internally, just how to use it.

8. ğğ«ğ¢ğ§ğœğ¢ğ©ğ¥ğ ğ¨ğŸ ğ„ğ§ğœğšğ©ğ¬ğ®ğ¥ğšğ­ğ¢ğ¨ğ§
âŸ Protect the internal state of objects from external manipulation.
âŸ This creates more robust systems by preventing unexpected side effects.

9. ğğ«ğ¢ğ§ğœğ¢ğ©ğ¥ğ ğ¨ğŸ ğ‹ğğšğ¬ğ­ ğŠğ§ğ¨ğ°ğ¥ğğğ ğ (ğ‹ğšğ° ğ¨ğŸ ğƒğğ¦ğğ­ğğ«)
âŸ Components should have limited knowledge of other components.
âŸ This "need-to-know basis" approach creates more modular, flexible systems.

10. ğ‹ğ¨ğ° ğ‚ğ¨ğ®ğ©ğ¥ğ¢ğ§ğ  & ğ‡ğ¢ğ ğ¡ ğ‚ğ¨ğ¡ğğ¬ğ¢ğ¨ğ§
âŸ Minimize dependencies between modules while ensuring each module has a clear, unified purpose.
âŸ This balance makes systems more maintainable and adaptable.
