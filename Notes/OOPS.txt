Object is an entity that has state(attributes) and behaviour.
Anything which exist in real world / physical world is object.

Class is just a blue print which says how my object will look like, class doesn't exist in physical world.

Women is a class bcoz it doesn't exist in real world, 
but neeta , gita , Himani , Jeel are objects , bcoz they do exist in real world.

in C++ Empty classes also give's 1 byte when we create object of them
class Empty{};

int main()
{
    Empty A,B;
    cout<<sizeof A <<" "<<sizeof B; 
    //o/p : 1   1 

    return 0;
}

Even though an empty class seems like it should have zero size, the C++ standard mandates that objects of any class must have a size greater than zero. This is to ensure that each object has a unique address.
The reason for this is due to the uniqueness requirement of object addresses in C++. Even though an empty class has no data members, the compiler ensures that each object of that class has a distinct address. Therefore, it assigns a non-zero size to ensure uniqueness.

If an empty class had a size of 0 bytes, then two different objects of the same class could have the same address, which would be a problem


watch second half of the below video
https://www.youtube.com/watch?v=iw1Xf_33YM0&ab_channel=CoderArmy
It's very very very important to watch it bcoz things discussed in this video is nowhere else present and no one has discussed it till now hence It's very important to watch it


Constructor
if we don't create any constructor then compiler will create 2 constructor default and copy constructor
if we create default constructor then compiler will still create 1 constructor i.e. copy constructor but now it won't create default constructor
if we create both default and copy constructor then now compiler will not going to create any constructor 

default constructor means , the constructor which doesn't take  take any argument 

for all the classes(for all the user defined data types) by default assingment operator(=) is overloaded into class

class Student{
 string name;
 int age;
 char grade;
 Student(string name, int age, char grade){
    this->name=name;
    this->age = age;
    this->grade=grade;
 }
};

int main(){
    Student S1("Yash,24,'A');
    Student S2;
    S2=S1;// this line will perfactly work and copy all data of S1 to S2

    //means by default although userdefined data types have different meaning for = operator still = is working fine means
  // compiler will be by default overloading = operator

}

Default destructor deosn't release dynamically allocated memory , means default constroctor can't prevent memory leak
you have to create your own destructor to prevent memory leak

Default destructor just do only one thing-> it just call destructor of parent class that's it


--------------------------------------------
class Programmer{
    static int count;
    int ObjectNumber;
    
    public:
    Programmer(){
        ObjectNumber=++count;
        cout<<"Object "<<ObjectNumber<<" constructed"<<endl;
    }
    ~Programmer(){
        cout<<endl<<"Object "<<ObjectNumber<<" destructed";
    }
};

int Programmer::count;

int main()
{   
    Programmer O1,O2,O3;
    Programmer *O4=new Programmer();
    return 0;
}
output:
Object 1 constructed
Object 2 constructed
Object 3 constructed
Object 4 constructed

Object 3 destructed
Object 2 destructed
Object 1 destructed

->three things to notice here 
1] constructors of the object are called in the order in which you are creating object
2] but destructor of the objects called in the reverse order, means the object you created first destroyed last, and the object you created last was destroyed first
3]destructor of the dynamically created object doesn't get's called and leads to memory leak
    however program execution completed but still It's destructor doesn't got called 
   so you have to use-> delete O4; then only It's memory will release , or destructor of O4 will be called

Why destructors are called in reverse Order ✅✅
This is because the objects are created in a Stack which follows the LIFO order, so when one object gets out of the stack, its destructor gets called. Also, the intuition behind this LIFO order is that, one object can be dependent of other object in case of copy constructor.

Eg: for Customer A4(A3), suppose A3 contains one dynamically allocated data, it means that A4 is dependent on A3.
Now, if A3 is destroyed first, then that heap memory is also going to be destroyed and A4 will not have any data to point to.


--------------------------------
What is difference between Encapsulation and Abstraction?

Encapsulation means binding objects properties(variables) and behaviour(methods) together at one place and after that making variables private and to access them defining public method like setters and getters this is called encapsulation of the data.

class Student{
    int age;
    int rollNum;
    int pin;
public:
    void setAge(int age){
        if(age>0 && age<100)
            this->age=age;
        else 
            cout<<"Invalid Age";
    }

    int getAge(int pin){
        if(this->pin==pin)
            return age;
        else
            cout<<"wrong password";
    }

    //similarly setRollNum and getRollNum can be defined conditionally like this
};

so above is the exaple of Encapsulation , no one can directly access Student's property(vars) and can't set any random values to age or roll number
if your age and rollNum are public then any one can set any wrong value to the age 

Student Amit;
Amit.age = -50;

So, this is violating Encapsulation property that's why difining all the vars as private is very important so that no one can randomly access and set garbage values to our precious data, and to set the age we need to provide It's public methods and there we need to have all the validations so, that only proper data goes to the data

here to get the data also you first need to provide your password , if password and username something like that matches then only you will get correct age otherwise you will get error
so, these things called Encapsulation

Encapsulation: defining all vars as private and providing public method to access them so that no one can directly access vars , and only using their proper method , someone can accesss the data and that also if they provide correct information to setters and getters then only

Abstraction means just providing relavent data to user and hiding all the actual implementation to user
(here user are those who are coders only, and using our methods or our class created by someone else )
end user just wants to call those methods and doesn't want to know how they are implemented actually behind the seen

pow(x,r)
in power function when you give 2 and 5 then it will give you 32 , so, user will just know how to use this method that's it , user doesn't know how actually 2 power 5 is getting calculated

sort(v.begin(),v.end())
user will give array to sort function and get the array sorted that's it user will not able to see which sorting algorithm is implemented inside sort fuction all those code inside sort fuction user doen't wants to know user just wants to use that function and get his work done

we are using many library function to get the substring, to get the toUpper, toLower all those are example of Abstraction, Actual implementation of those function are hidden from us because we don't want to know how they are implemented , we just want to use them and wants to done our work that's it.

So, hiding the actual implementation(unneccessary details) from the end user and just providing usefull information to user that's Abstraction.

Inheritance: is all about re-using the already available code and avoiding re-writing same code again and again 
that can be achived by creating base class and derived classes
all the property present in base class can be re-used in derived class insted of re-writing them

private we knows that we use it so that no one from outside can access them and set random values to vars
public we use so that using publically available methods external code can set or get values of vars using some proper mechanism only instead of randomly accessing anything 

so, using private and public we achieved encapsulation
but what is the need of protected?

protected members only can be accessed by derived classes and outsider's still can't access them
after encapsulation we were in need of code reusability and for that purpose if we can't use private members bcoz they can't be accessed outside class and we also can't use public members to define vars bcoz otherwise randomly any one can change any value and where -ve values are not expected there also someone can set -ve values , 

so, to implement code reusability , protected access specifier was invented
protected members are behave as private for external code, bcoz other's can't access it 
and for derived classes it behaves as public bcoz derived clases can use them for code re-usability

so, using protected re-usability also ensured and for external code, encapsulaiton also ensured bcoz protected code works as private for all the external code.

