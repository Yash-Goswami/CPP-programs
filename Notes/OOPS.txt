Object is an entity that has state(attributes) and behaviour.
Anything which exist in real world / physical world is object.

Class is just a blue print which says how my object will look like, class doesn't exist in physical world.

Women is a class bcoz it doesn't exist in real world, 
but neeta , gita , Himani , Jeel are objects , bcoz they do exist in real world.

in C++ Empty classes also give's 1 byte when we create object of them
class Empty{};

int main()
{
    Empty A,B;
    cout<<sizeof A <<" "<<sizeof B; 
    //o/p : 1   1 

    return 0;
}

Even though an empty class seems like it should have zero size, the C++ standard mandates that objects of any class must have a size greater than zero. This is to ensure that each object has a unique address.
The reason for this is due to the uniqueness requirement of object addresses in C++. Even though an empty class has no data members, the compiler ensures that each object of that class has a distinct address. Therefore, it assigns a non-zero size to ensure uniqueness.

If an empty class had a size of 0 bytes, then two different objects of the same class could have the same address, which would be a problem


watch second half of the below video
https://www.youtube.com/watch?v=iw1Xf_33YM0&ab_channel=CoderArmy
It's very very very important to watch it bcoz things discussed in this video is nowhere else present and no one has discussed it till now hence It's very important to watch it


Constructor
if we don't create any constructor then compiler will create 2 constructor default and copy constructor
if we create default constructor then compiler will still create 1 constructor i.e. copy constructor but now it won't create default constructor
if we create both default and copy constructor then now compiler will not going to create any constructor 

default constructor means , the constructor which doesn't take  take any argument 

for all the classes(for all the user defined data types) by default assingment operator(=) is overloaded into class

class Student{
 string name;
 int age;
 char grade;
 Student(string name, int age, char grade){
    this->name=name;
    this->age = age;
    this->grade=grade;
 }
};

int main(){
    Student S1("Yash,24,'A');
    Student S2;
    S2=S1;// this line will perfactly work and copy all data of S1 to S2

    //means by default although userdefined data types have different meaning for = operator still = is working fine means
  // compiler will be by default overloading = operator

}

Default destructor deosn't release dynamically allocated memory , means default constroctor can't prevent memory leak
you have to create your own destructor to prevent memory leak

Default destructor just do only one thing-> it just call destructor of parent class that's it


--------------------------------------------
class Programmer{
    static int count;
    int ObjectNumber;
    
    public:
    Programmer(){
        ObjectNumber=++count;
        cout<<"Object "<<ObjectNumber<<" constructed"<<endl;
    }
    ~Programmer(){
        cout<<endl<<"Object "<<ObjectNumber<<" destructed";
    }
};

int Programmer::count;

int main()
{   
    Programmer O1,O2,O3;
    Programmer *O4=new Programmer();
    return 0;
}
output:
Object 1 constructed
Object 2 constructed
Object 3 constructed
Object 4 constructed

Object 3 destructed
Object 2 destructed
Object 1 destructed

->three things to notice here 
1] constructors of the object are called in the order in which you are creating object
2] but destructor of the objects called in the reverse order, means the object you created first destroyed last, and the object you created last was destroyed first
3]destructor of the dynamically created object doesn't get's called and leads to memory leak
    however program execution completed but still It's destructor doesn't got called 
   so you have to use-> delete O4; then only It's memory will release , or destructor of O4 will be called

Why destructors are called in reverse Order ✅✅
This is because the objects are created in a Stack which follows the LIFO order, so when one object gets out of the stack, its destructor gets called. Also, the intuition behind this LIFO order is that, one object can be dependent of other object in case of copy constructor.

Eg: for Customer A4(A3), suppose A3 contains one dynamically allocated data, it means that A4 is dependent on A3.
Now, if A3 is destroyed first, then that heap memory is also going to be destroyed and A4 will not have any data to point to.

